#pragma config(Sensor, S1,     ColourLeft,     sensorEV3_Color)
#pragma config(Sensor, S2,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     ColourRight,    sensorEV3_Color)
#pragma config(Motor,  motorA,          motorLeft,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          motorRight,    tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#pragma config(Sensor, S3,     sonar3,         sensorEV3_Ultrasonic)

#pragma DebuggerWindows("debugStream")


// the array of degree space of turning the robot
int myTurn[4] = { 600, 700, 800, 900};
int myArray[4] = { 5, 8, 12, 15};
//// Array for random delay of next new speed differ of both motors.
int myTime[4] = { 10, 20, 30, 40};

//// diretion of the robot, 0 means left and 1 means right
int dir = 0;

//// count the escapled time of the speed differ
int counter = 0;

//// the delay time util the update of speed differ
int latency = 20;

// Distance to maintain to the target (30 cm)
const int distanceToMaintain = 3;
int currentDistance = 0;

short currentColourLeft;
short currentColourRight;
int turningSpeed = 70;
int robotSpeed = 15;

int tinyTimer = 10;
int smallTimer = 300;
int mediumTimer = 450;
int largeTimer = 900;
int randomCoolDown = 0;


int left = 15;
int right = 15;
/*
	status:
	Wandering:0
	trailFollowing: 1
	objectDetetection: 2
*/
int status = 2;


void playSound() {
	playTone(400, 20);
	sleep(500);
}

void turnLeft(int theTime){
		setMotorSpeed(motorLeft, 0);
		setMotorSpeed(motorRight, turningSpeed);
		sleep(theTime);

}

void turnRight(int theTime){
		setMotorSpeed(motorLeft, turningSpeed);
		setMotorSpeed(motorRight, 0);
		sleep(theTime);
}

void randomTurn(){
	int temp = random(2);
	if(temp == 0){
		turnLeft(smallTimer);
	}else {
		turnRight(smallTimer);
	}
}

void move(int leftMotorSpeed, int rightmotorSpeed, int timeLast, int isRandom){
		setMotorSpeed(motorLeft, leftMotorSpeed);
		setMotorSpeed(motorRight, rightmotorSpeed);
		sleep(timeLast);
}

// When Status = 0
void wandering() {

	//// Read the sonar sensor
	//currentDistance = SensorValue[sonarSensor];

	//if ((distanceToMaintain - currentDistance) < -2)
	//{
	//	status = 2;
	//}

	counter++;
	// If the counter is less than latency
	// it is time to update the speed of each motor
	if(counter > latency){

		// if it is going right
		// just reset the left motor to default value 50
		// then add a random value to 50 as the new speed of
		// right motor to make it turn left
		if(dir == 1 ){
				right = robotSpeed;
				left += myArray[random(3)];
				//writeDebugStreamLine("Right  %d",myArray[random(3)] );
				dir = 0;
		} else {// if it is going left
				// just reset the right motor to default value 50
				// then add a random value to 50 as the new speed of
				// left motor to make it turn right
				left = robotSpeed;
				right += myArray[random(3)];
				//writeDebugStreamLine("Left	%d",myArray[random(3)]);
				dir = 1;
		}

		// reset the counter and update the latency
		counter =0;
		latency = myTime[random(3)];
	}
	// For debugging
	//writeDebugStreamLine("The left speed is %d and the right is %d ", left, right);

	//update each speed od the motor
	setMotorSpeed(motorLeft, left);
	setMotorSpeed(motorRight, right);

	// delay for 0.005 second
	sleep(50);
} // wandering() ends

// When Status = 1
void trailFollowing() {
	displayCenteredBigTextLine(4, "L: %d R: %d ", currentColourLeft, currentColourRight);
	
	if(currentColourLeft > currentColourRight ){
		setMotorSpeed(motorLeft, robotSpeed + 20);
		setMotorSpeed(motorRight, robotSpeed);
		displayCenteredBigTextLine(7, "turn right ");
	} else {
		setMotorSpeed(motorLeft, robotSpeed );
		setMotorSpeed(motorRight, robotSpeed+ 20);
		displayCenteredBigTextLine(7, "turn left ");
	}
	
} // trailFollowing() ends

// When Status = 2
void objectDetection() {

	// Read the sensor
	currentDistance = SensorValue[sonarSensor];

	writeDebugStreamLine("Dist: %3d cm", currentDistance);
			writeDebugStreamLine("Maintain - current: %3d cm", distanceToMaintain - currentDistance);


	// We're too far away, move forward
	if ((distanceToMaintain - currentDistance) < -2)
	{
		motor[motorLeft] = 30;
		motor[motorRight] = 30;
	}
	// We're good, don't go anywhere
	else
	{
		motor[motorLeft] = 0;
		motor[motorRight] = 0;
	}

	if (currentDistance < 6) {
			sleep(2000);
			motor[motorLeft] = -30;
		  motor[motorRight] = -30;
		  sleep(2000);
		  randomTurn();
		  //status = 0;
	}

	//Loop to monitor value in Sensor debugger window
	sleep(50);

} // objectDetection() ends

/*
    Main function
    Ifiniti while loop
*/
task main()
{
	writeDebugStreamLine("Here we go XXXXXXXXXXXXXXXXXXX");
	int sensorDifference = 0;
	while (true)
	{
		currentColourLeft = SensorValue[ColourLeft];
		currentColourRight = SensorValue[ColourRight];

		// if(status == 0)
		// {
			// displayCenteredBigTextLine(4, "Wandering");
			// wandering();
		// }
		if(currentColourLeft < 20 || currentColourRight < 20)
		{
			trailFollowing();
		
		}
		// if (status == 2)
		// {
			// objectDetection();
		// }

	} // While ends

}// Main ends