#pragma config(Sensor, S1,     ColourLeft,     sensorEV3_Color)
#pragma config(Sensor, S3,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     ColourRight,    sensorEV3_Color)
#pragma config(Motor,  motorA,          motorLeft,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          motorRight,    tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//



#pragma DebuggerWindows("debugStream")


// the array of degree space of turning the robot
int myTurn[4] = { 600, 700, 800, 900};
int myArray[4] = { 10, 40, 20, 30};
//// Array for random delay of next new speed differ of both motors.
int myTime[4] = { 10, 20, 30, 40};

//// diretion of the robot, 0 means left and 1 means right
int dir = 0;

//// count the escapled time of the speed differ
int counter = 0;

//// the delay time util the update of speed differ
int latency = 20;

int currentDistance = 0;
short currentColourLeft;
short currentColourRight;
int turningSpeed = 70;
int robotSpeed = 15;

int tinyTimer = 10;
int smallTimer = 300;
int mediumTimer = 450;
int largeTimer = 900;
int randomCoolDown = 0;


int left = 15;
int right = 15;
/*
	status:
	Wandering:0
	lineFolowing: 1
	objectDeteted: 2
*/
int status = 0;
int beepStatus = 0;

///*
//void playSound() {
//	playTone(400, 20);
//	while(bSoundActive)
//		sleep(1);
//  writeDebugStreamLine("XXXXXXXXXXXXXXXXXXX");
//}
//*/

/*
void randomTurn(){
	int temp = random(2);
	if(temp == 0){
		turnLeft(mediumTimer);
	}else {
		turnRight(mediumTimer);
	}
}

void sonarSensorTesting() {
	// Distance to maintain to the target (30 cm)
	const int distanceToMaintain = 30;

		// Read the sensor
		currentDistance = SensorValue[sonarSensor];
		displayCenteredBigTextLine(4, "Dist: %3d cm", currentDistance);

		// We're too far away, move forward
		if ((distanceToMaintain - currentDistance) < -2)
		{
			motor[motorLeft] = 30;
			motor[motorRight] = 30;
		}
		// We're too close, move backwards
		else if ((distanceToMaintain - currentDistance) > 2)
		{
			motor[motorLeft] = -30;
			motor[motorRight] = -30;
		}
		// We're good, don't go anywhere
		else
		{
			motor[motorLeft] = 0;
			motor[motorRight] = 0;
		}

		//Loop to monitor value in Sensor debugger window
		sleep(50);
}

*/
void resetRandomTurn(){
			randomCoolDown = 0;
			setLEDColor(ledGreen);
}

/*
void checkRandomCoolDown() {
	if(randomCoolDown == 0 ) {
			turnOffRandomTurn();
	}
}
*/


void wandering(){
counter++;
				// If the counter is less than latency
				// it is time to update the speed of each motor
				if(counter > latency){
						// if it is going right
						// just reset the left motor to default value 50
						// then add a random value to 50 as the new speed of
						// right motor to make it turn left
						if(dir == 1 ){
								right = robotSpeed;
								left += myArray[random(3)];
								//writeDebugStreamLine("Right  %d",myArray[random(3)] );
								dir = 0;
						} else {// if it is going left
								// just reset the right motor to default value 50
								// then add a random value to 50 as the new speed of
								// left motor to make it turn right
								left = robotSpeed;
								right += myArray[random(3)];
								//writeDebugStreamLine("Left	%d",myArray[random(3)]);
								dir = 1;
						}

						// reset the counter and update the latency
						counter =0;
						latency = myTime[random(3)];
				}
				// For debugging
				//writeDebugStreamLine("The left speed is %d and the right is %d ", left, right);

				//update each speed od the motor
				setMotorSpeed(motorLeft, left);
				setMotorSpeed(motorRight, right);


}

/*
    Main function
    Ifiniti while loop
*/
task main()
{
	writeDebugStreamLine("Here we go XXXXXXXXXXXXXXXXXXX");
	while (true)
	{
		//counter++;

		currentColourLeft = SensorValue[ColourLeft];

		currentColourRight = SensorValue[ColourRight];
						//sonarSensorTesting();
		currentDistance = SensorValue[sonarSensor];

		// if(currentDistance <=92) {
			// status  = 2;
		// } else {
			// status =0;
			// robotSpeed = 15;
		// }

if ((currentColourLeft < 17 && currentColourRight < 17 )){
beepStatus=1;
}

		if(status == 0 &&(currentColourLeft < 17 || currentColourRight < 17 )){ // for both sensors sensing black
				status = 1;
				resetRandomTurn();
		}
		if((SensorValue[ColourLeft] > 20 && SensorValue[ColourRight] > 20) && status==1 && beepStatus==1){
		status = 0;
		beepStatus = 0;
			displayCenteredBigTextLine(10, "beep ");
		setSoundVolume(50);
	playTone(100	, 100);



	}

		displayCenteredBigTextLine(7, "Status: %d ", status);


		if (currentDistance > 6 &&currentDistance <=92) {
				//robotSpeed = 0;
beepStatus = 0;


				while(currentDistance > 5 &&currentDistance <=92) {
			  	//int speed = 50;

			  	displayCenteredBigTextLine(6, " %d", currentDistance);

	  			setMotorSpeed(motorLeft, currentDistance);
					setMotorSpeed(motorRight,currentDistance);
					//sleep(100);

			  	currentDistance = SensorValue[sonarSensor];
			  }

			  	//setMotorSpeed(motorLeft, 50);
				//setMotorSpeed(motorRight, -50);
				//sleep(700);

				status =0;
			} else if(currentDistance < 3.5){
						setMotorSpeed(motorLeft, 0);
						setMotorSpeed(motorRight, 0);
						sleep(1000);
						setMotorSpeed(motorLeft, -30);
						setMotorSpeed(motorRight, -30);
						sleep(1000);

							setMotorSpeed(motorLeft, -50);
							setMotorSpeed(motorRight, 50);
							sleep(700);

			}
			else if(status == 0) {
				displayCenteredBigTextLine(4, "Wandering");
				wandering();
				// delay for 0.005 second




			} else if(status == 1) { // Arjun
	  		displayCenteredBigTextLine(4, "L: %d , R: %d", SensorValue[ColourLeft], SensorValue[ColourRight]);

				 if(currentColourLeft > currentColourRight){ // for left sensor sensing black
						setMotorSpeed(motorLeft, robotSpeed+30);
						setMotorSpeed(motorRight, -10);
				} else { // for right sensor sensing black
						setMotorSpeed(motorLeft, -10);
						setMotorSpeed(motorRight, robotSpeed+30);
				}
		} else{
		setMotorSpeed(motorLeft, 30);
						setMotorSpeed(motorRight, 30);
	}


	}
}
